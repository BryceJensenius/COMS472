package edu.iastate.cs472.proj1;

import java.io.FileNotFoundException;

import edu.iastate.cs472.proj1.Move;
import edu.iastate.cs472.proj1.Heuristic;
/**
 *  
 * @author Bryce Jensenius
 *
 */

public class EightPuzzle 
{
	/**
	 * This static method solves an 8-puzzle with a given initial state using three heuristics. The 
	 * first two, allowing single moves only, compare the board configuration with the goal configuration 
	 * by the number of mismatched tiles, and by the Manhattan distance, respectively.  The third 
	 * heuristic, designed by yourself, allows double moves and must be also admissible.  The goal 
	 * configuration set for all puzzles is
	 * 
	 * 			1 2 3
	 * 			8   4
	 * 			7 6 5
	 * 
	 * @param s0
	 * @return a string specified in the javadoc below
	 */
	public static String solve8Puzzle(State s0)
	{
		// 1) If there exists no solution, return a message that starts with "No solution 
		//    exists for the following initial state:" and follows with a blank line and 
		//    then what would be the output from a call s0.toString(). See the end of 
		//    Section 6 in the project description for an example. 
				

		// 2) Otherwise, solve the puzzle with the three heuristics.  The two solutions generated by
		//    the first two heuristics may be different but must have the same length for optimality. 
		
		Heuristic h[] = {Heuristic.TileMismatch, Heuristic.ManhattanDist, Heuristic.DoubleMoveHeuristic }; 
		String [] moves = new String[3]; 
		
		try{
			for (int i = 0; i < 3; i++){
				// Print time before and after each A* search and report duration
				moves[i] = AStar(s0, h[i]);
			}
		}catch(IllegalStateException e){
			return "No solution exists for the following initial state:\n\n" + s0.toString();
		}
		
		// 3) Combine the three solution strings into one that would print out in the 
		//    output format specified in Section 6 of the project description.
		StringBuilder result = new StringBuilder();
		result.append(moves[0] + "\n");
		result.append(moves[1] + "\n");
		result.append(moves[2] + "\n");
		return result.toString();
	}

	
	/**
	 * This method implements the A* algorithm to solve the 8-puzzle with an input initial state s0. 
	 * The algorithm implementation is described in Section 3 of the project description. 
	 * 
	 * Precondition: the puzzle is solvable with the initial state s0.
	 * 
	 * @param s0  initial state
	 * @param h   heuristic 
	 * @return    solution string 
	 */
	public static String AStar(State s0, Heuristic h)
	{
		if(s0 == null || h == null){
			throw new IllegalArgumentException("Initial state or heuristic is null");
		}
		if(!s0.solvable()){
			throw new IllegalStateException("No solution exists for the following initial state:\n\n" + s0.toString());
		}

		// Initialize the two lists used by the algorithm. 
		OrderedStateList OPEN = new OrderedStateList(h, true); 
		OrderedStateList CLOSE = new OrderedStateList(h, false);
		State.heu = h;
		OPEN.addState(s0);
		
		// Implement the algorithm described in Section 3 to solve the puzzle. 
		// Once a goal state s is reached, call solutionPath(s) and return the solution string. 
		while(OPEN.size() > 0){
			State openS = OPEN.remove();
			CLOSE.addState(openS);
			if(openS.isGoalState()){
				return solutionPath(openS);
			}
			for(Move m : Move.values()){
				if(h != Heuristic.DoubleMoveHeuristic
						&& (m == Move.DBL_LEFT || m == Move.DBL_RIGHT || m == Move.DBL_UP || m == Move.DBL_DOWN)){
					continue; // Skip double moves for first two heuristics
				}

				State successor;
				try{
					successor = openS.successorState(m);
				} catch(IllegalArgumentException e){
					continue; // Skip illegal moves
				}
				
				// Don't go back to the parent/predecessor again
				if (openS.predecessor != null && successor.equals(openS.predecessor)) continue;

				if(CLOSE.findState(successor) == null){ // Not in CLOSE
					State existing = OPEN.findState(successor); // See if we have opened it before
					if(existing == null){ // Not in OPEN or CLOSE so add to OPEN
						OPEN.addState(successor);
					}else if(successor.compareTo(existing) < 0){ // Must be in OPEN
						OPEN.removeState(existing); // Remove the existing state
						OPEN.addState(successor); // Add the new state
					}
				}else{ // Must be in CLOSE
					State existing = CLOSE.findState(successor); // Get the existing state
					if(successor.compareTo(existing) < 0){ // Found a better path to closed state
						CLOSE.removeState(existing); // Remove from CLOSE
						OPEN.addState(successor); // Add to OPEN
					}
				}
			}
		}
		throw new IllegalStateException("OPEN list is empty, Failed to solve");	
	}
	
	
	
	/**
	 * From a goal state, follow the predecessor link to trace all the way back to the initial state. 
	 * Meanwhile, generate a string to represent board configurations in the reverse order, with 
	 * the initial configuration appearing first. Between every two consecutive configurations 
	 * is the move that causes their transition. A blank line separates a move and a configuration.  
	 * In the string, the sequence is preceded by the total number of moves and a blank line. 
	 * 
	 * See Section 6 in the projection description for an example. 
	 * 
	 * Call the toString() method of the State class. 
	 * 
	 * @param goal
	 * @return
	 */
	private static String solutionPath(State goal)
	{
		if(goal == null){
			throw new IllegalArgumentException("Goal state is null");
		}
		StringBuilder result = new StringBuilder();
		int moves = 0;
		State current = goal;
		// Count moves by following the predecessor links (the path from initial to goal)
		while(current.predecessor != null){
			moves++;
			current = current.predecessor;
		}
		result.append("\n" + moves);
		// output in the format "9 moves in total (heuristic: number of mismatached tiles)"
		switch(State.heu){
			case TileMismatch:
				result.append(" moves in total (heuristic: number of mismatched tiles)\n\n");
				break;
			case ManhattanDist:
				result.append(" moves in total (heuristic: the Manhattan distance)\n\n");
				break;
			case DoubleMoveHeuristic:
				result.append(" moves in total (heuristic: double moves allowed)\n\n");
				break;
			default:
				result.append(" moves in total (heuristic: unknown)\n\n");
				break;
		}
		
		// Now we need to build the path in reverse order
		StringBuilder path = new StringBuilder();
		current = goal;
		// Build the path by walking predecessor links backwards and prepending each step
		while(current.predecessor != null){
			path.insert(0, "\n" + current.move + "\n\n" + current.toString() + "\n"); // Prepend the current state and move
			current = current.predecessor; // Move to the predecessor state
		}
		path.insert(0, current.toString() + "\n"); // Add the initial state at the start
		result.append(path.toString());
		
		return result.toString();
	}
}