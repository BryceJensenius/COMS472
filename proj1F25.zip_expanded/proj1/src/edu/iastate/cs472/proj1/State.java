package edu.iastate.cs472.proj1;

import java.io.File;
import java.io.FileNotFoundException;

import java.util.Scanner;

import edu.iastate.cs472.proj1.Move;
import edu.iastate.cs472.proj1.Heuristic;
import edu.iastate.cs472.proj1.StateComparator;

/**
 *  
 * @author Bryce Jensenius
 *
 */


/**
 * This class represents a board configuration in the 8-puzzle.  Only the initial configuration is 
 * generated by a constructor, while intermediate configurations will be generated via calling
 * the method successorState().  State objects will form two circular doubly-linked lists OPEN and 
 * CLOSED, which will be used by the A* algorithm to search for a path from a given initial board
 * configuration to the final board configuration below: 
 * 
 *  1 2 3 
 *  8   4
 *  7 6 5
 *
 * The final configuration (i.e., the goal state) above is not explicitly represented as an object 
 * of the State class. 
 */

public class State implements Cloneable, Comparable<State>
{
	public int[][] board; 		// configuration of tiles 
	
	public State previous;    	// previous node on the OPEN/CLOSED list
	public State next; 			// next node on the OPEN/CLOSED list
	public State predecessor; 	// predecessor node on the path from the initial state 
	
	public Move move;           // the move that generated this state from its predecessor
	public int numMoves; 	    // number of moves from the initial state to this state

	public static Heuristic heu; // heuristic used. shared by all the states. 
	
	private int numMismatchedTiles = -1;    // number of mismatched tiles between this state 
	                                        // and the goal state; negative if not computed yet.
	private int ManhattanDistance = -1;     // Manhattan distance between this state and the 
	                                        // goal state; negative if not computed yet. 
	private int numSingleDoubleMoves = -1;  // number of single and double moves with each double 
										    // move counted as one; negative if not computed yet. 

	
	/**
	 * Constructor (for the initial state).  
	 * 
	 * It takes a 2-dimensional array representing an initial board configuration. The empty 
	 * square is represented by the number 0.  
	 * 
	 *     a) Initialize all three links previous, next, and predecessor to null.  
	 *     b) Set move to null and numMoves to zero.
	 * 
	 * @param board
	 * @throws IllegalArgumentException		if board is not a 3X3 array or its nine entries are 
	 * 										not respectively the digits 0, 1, ..., 8. 
	 */
    public State(int[][] board) throws IllegalArgumentException
    {
    	// Check that the board has correct number of rows
    	if(board == null || board.length != 3 || board[0].length != 3) throw new IllegalArgumentException("Board must have 3 rows ");
    	
    	// Check each row has 3 columns
        for (int i = 0; i < board.length; i++) {
            if (board[i] == null || board[i].length != 3)
                throw new IllegalArgumentException("Each row must have 3 columns");
        }

    	// Check that all values are 0-8 no duplicates
        boolean[] seen = new boolean[9];
		for(int j = 0; j < board.length; j++) {
			for(int i = 0; i < board[0].length; i++) {
				int val = board[j][i];
				if(seen[val] || val < 0 || val > 8)  throw new IllegalArgumentException("Board must contain all values 0-8 exactly once");
				seen[val] = true;
			}
		}
		
		// Assign default fields
    	previous = null;
    	next = null;
    	predecessor = null;
    	this.board = board;
    	move = null;
    	numMoves = 0;
	}
    
    
    /**
     * Constructor (for the initial state) 
     * 
     * It takes a state from an input file that has three rows, each containing three digits 
     * separated by exactly one blank.  Every row starts with a digit. The nine digits are 
     * from 0 to 8 with no duplicates.  
     * 
     * Do the same initializations as for the first constructor. 
     * 
     * @param inputFileName
     * @throws FileNotFoundException
     * @throws IllegalArgumentException  if the file content does not meet the above requirements. 
     */
    public State (String inputFileName) throws FileNotFoundException, IllegalArgumentException
    {
    	File fp = new File(inputFileName);
    	Scanner fscnr = new Scanner(fp); // open scanner to inputted file
    	int[][] board = new int[3][3];
    	try {
            boolean[] seen = new boolean[9];
            for(int i = 0; i < 3; i++) {
            	if(!fscnr.hasNextLine()) throw new IllegalArgumentException("File must have exactly 3 line");
                String[] vals = fscnr.nextLine().split(" "); // parse the space separeted values on the line
                if (vals.length != 3) {
                    throw new IllegalArgumentException("Each line must have 3 space-separated numbers");
                }
                for(int j = 0; j < 3; j++) {
                	int val = Integer.parseInt(vals[j]);
    				if(seen[val] || val < 0 || val > 8)  throw new IllegalArgumentException("Board must contain all values 0-8 exactly once");
    				seen[val] = true;
    				board[i][j] = val;
                }
            }
            
        	if(fscnr.hasNextLine()) throw new IllegalArgumentException("File must have exactly 3 lines");
    	} catch(NumberFormatException  e) {
    		throw new IllegalArgumentException("File Must Contain Only Digits 0-8");
    	} finally {
    		fscnr.close();
    	}
    	
		// Assign default fields
    	previous = null;
    	next = null;
    	predecessor = null;
    	this.board = board;
    	move = null;
    	numMoves = 0;
	}
    
    
    /**
     * Generate the successor state resulting from a given move.  Throw an exception if the move 
     * cannot be executed.  Besides setting the array board[][] properly, you also need to do the 
     * following:
     * 
     *     a) set the predecessor of the successor state to this state;
     *     b) set the private instance variable move of the successor state to the parameter m; 
     *     c) Set the links next and previous to null;  
     *     d) Set the variable numMoves for the successor state to this.numMoves + 1. 
     * 
     * @param m  one of the moves LEFT, RIGHT, UP, DOWN, DBL_LEFT, DBL_RIGHT, DBL_UP, and DBL_DOWN
     * @return null  			if the successor state is this.predecessor
     *         successor state  otherwise 
     * @throws IllegalArgumentException if LEFT when the empty square is in the right column, or  
     *                                  if RIGHT when the empty square is in the left column, or
     *                                  if UP when the empty square is in the bottom row, or 
     *                                  if DOWN when the empty square is in the top row, or
     *                                  if DBL_LEFT when the empty square is not in the left column, or 
     *                                  if DBL_RIGHT when the empty square is not in the right column, or 
     *                                  if DBL_UP when the empty square is not in the top row, or 
     *                                  if DBL_DOWN when the empty square is not in the bottom row. 
     */                                  
    public State successorState(Move m) throws IllegalArgumentException 
    {
        int[][] newBoard = copyBoard(); // Create a copy of the current board to modify
        int[] emptyPos = getEmptyTilePosition(); // Get the position of the empty tile [y,x]
    	switch(m){
    		case LEFT:
    			if(emptyPos[1] == 2) { // Empty tile in right column
    				throw new IllegalArgumentException("Cannot move LEFT when empty tile is in right column");
    			}
                newBoard[emptyPos[0]][emptyPos[1]] = newBoard[emptyPos[0]][emptyPos[1]+1]; // Move tile left of empty onto empty
                newBoard[emptyPos[0]][emptyPos[1]+1] = 0; // Set the tile that was moved to empty
    			break;
    		case RIGHT:
                if(emptyPos[1] == 0) { // Empty tile in left column
    				throw new IllegalArgumentException("Cannot move RIGHT when empty tile is in left column");
    			}
                newBoard[emptyPos[0]][emptyPos[1]] = newBoard[emptyPos[0]][emptyPos[1]-1]; // Move tile right of empty onto empty
                newBoard[emptyPos[0]][emptyPos[1]-1] = 0; // Set the tile that was moved to empty
    			break;
    		case UP:
                if(emptyPos[0] == 2) { // Empty tile in bottom row
                    throw new IllegalArgumentException("Cannot move UP when empty tile is in bottom row");
                }
                newBoard[emptyPos[0]][emptyPos[1]] = newBoard[emptyPos[0]+1][emptyPos[1]]; // Move tile below empty onto empty
                newBoard[emptyPos[0]+1][emptyPos[1]] = 0; // Set the tile that was moved to empty
    			break;
    		case DOWN:
                if(emptyPos[0] == 0) { // Empty tile in top row
                    throw new IllegalArgumentException("Cannot move DOWN when empty tile is in top row");
                }
                newBoard[emptyPos[0]][emptyPos[1]] = newBoard[emptyPos[0]-1][emptyPos[1]]; // Move tile above empty onto empty
                newBoard[emptyPos[0]-1][emptyPos[1]] = 0; // Set the tile that was moved to empty
    			break;
    		case DBL_LEFT:
                if(emptyPos[1] != 0) { // Empty tile not in left column
                    throw new IllegalArgumentException("Cannot move DBL_LEFT when empty tile is not in left column");
                }
                newBoard[emptyPos[0]][emptyPos[1]] = newBoard[emptyPos[0]][emptyPos[1]+1]; // Move tile right of empty onto empty
                newBoard[emptyPos[0]][emptyPos[1]+1] = newBoard[emptyPos[0]][emptyPos[1]+2]; // Move tile two right of empty onto tile right of empty
                newBoard[emptyPos[0]][emptyPos[1]+2] = 0; // Set the tile that was moved to empty
    			break;
    		case DBL_RIGHT:
                if(emptyPos[1] != 2) { // Empty tile not in right column
                    throw new IllegalArgumentException("Cannot move DBL_RIGHT when empty tile is not in right column");
                }
                newBoard[emptyPos[0]][emptyPos[1]] = newBoard[emptyPos[0]][emptyPos[1]-1]; // Move tile left of empty onto empty
                newBoard[emptyPos[0]][emptyPos[1]-1] = newBoard[emptyPos[0]][emptyPos[1]-2]; // Move tile two left of empty onto tile left of empty
                newBoard[emptyPos[0]][emptyPos[1]-2] = 0; // Set the tile that was moved to empty
    			break;
    		case DBL_UP:
                if(emptyPos[0] != 0) { // Empty tile not in top row
                    throw new IllegalArgumentException("Cannot move DBL_UP when empty tile is not in top row");
                }
                newBoard[emptyPos[0]][emptyPos[1]] = newBoard[emptyPos[0]+1][emptyPos[1]]; // Move tile below empty onto empty
                newBoard[emptyPos[0]+1][emptyPos[1]] = newBoard[emptyPos[0]+2][emptyPos[1]]; // Move tile two below empty onto tile below empty
                newBoard[emptyPos[0]+2][emptyPos[1]] = 0; // Set the tile that was moved to empty
    			break;
    		default: // DBL_DOWN
                if(emptyPos[0] != 2) { // Empty tile not in bottom row
                    throw new IllegalArgumentException("Cannot move DBL_DOWN when empty tile is not in bottom row");
                }
                newBoard[emptyPos[0]][emptyPos[1]] = newBoard[emptyPos[0]-1][emptyPos[1]]; // Move tile above empty onto empty
                newBoard[emptyPos[0]-1][emptyPos[1]] = newBoard[emptyPos[0]-2][emptyPos[1]]; // Move tile two above empty onto tile above empty
                newBoard[emptyPos[0]-2][emptyPos[1]] = 0; // Set the tile that was moved to empty
    			break;
    	}
        State s = new State(newBoard); // Create the new state with the modified board
        s.predecessor = this;
        s.move = m;
        s.numMoves = this.numMoves + 1;
    	return s;
    }

    /*
     * Get the [y,x] position of the empty tile (0) in the board.
     * @return an array of two integers where the first integer is the row (y) and the second is the column (x) of the empty tile
     */
    private int[] getEmptyTilePosition() {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (board[i][j] == 0) {
                    return new int[]{i, j}; // Return the row and column of the empty tile
                }
            }
        }
        throw new IllegalStateException("No empty tile found in the board");
    }

    private int[][] copyBoard() {
        int[][] newBoard = new int[3][3];
        // Copy each row of the board to the new board. copying the 3 elements
        for (int i = 0; i < 3; i++) {
            System.arraycopy(board[i], 0, newBoard[i], 0, 3);
        }
        return newBoard;
    }

    private int countInversions() {
        int[] flatBoard = new int[9];
        int index = 0;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                flatBoard[index++] = board[i][j];
            }
        }

        int inversions = 0;
        for (int i = 0; i < flatBoard.length; i++) {
            for (int j = i + 1; j < flatBoard.length; j++) {
                // Count numbers less than this, ignoring the empty tile (0)
                if (flatBoard[i] != 0 && flatBoard[j] != 0 && flatBoard[i] > flatBoard[j]) {
                    inversions++;
                }
            }
        }
        return inversions;
    }
    
        
    /**
     * Determines if the board configuration in this state can be rearranged into the goal configuration. 
     * According to the PowerPoint notes that introduce the 8-puzzle, we check if this state has an odd number 
     * of inversions. 
     */
    /**
     * 
     * @return true if the puzzle starting in this state can be rearranged into the goal state.
     */
    public boolean solvable()
    {
    	return countInversions() % 2 == 1; // Odd number of inversions means solvable
    }
    
    
    /**
     * Check if this state is the goal state, namely, if the array board[][] stores the following contents: 
     * 
     * 		1 2 3 
     * 		8 0 4 
     * 		7 6 5 
     * 
     * @return
     */
    public boolean isGoalState()
    {
    	return computeNumMismatchedTiles() == 0;
    }
    
    
    /**
     * Write the board configuration according to the following format:
     * 
     *     a) Output row by row in three lines with no indentations.  
     *     b) Two adjacent tiles in each row have exactly one blank in between. 
     *     c) The empty square is represented by a blank.  
     *     
     * For example, 
     * 
     * 2   3
     * 1 8 4
     * 7 6 5  
     * 
     */
    @Override 
    public String toString()
    {
    	StringBuilder sb = new StringBuilder();
    	for(int i = 0; i < 3; i++) {
    		for(int j = 0; j < 3; j++) {
    			sb.append(board[i][j] == 0 ? " " : board[i][j]);
    			if(j < 2) sb.append(" ");
    		}
    		if(i < 2) sb.append(System.lineSeparator());
    	}
    	return sb.toString(); 
    }
    
    
    /**
     * Create a clone of this State object by copying over the board[][]. Set the links previous,
     * next, and predecessor to null. 
     * 
     * The method is called by SuccessorState(); 
     */
    @Override
    public Object clone()
    {
        State c = new State(copyBoard());
        c.move = this.move;
        c.numMoves = this.numMoves;
    	return c; 
    }
  

    /**
     * Compare this state with the argument state.  Two states are equal if their arrays board[][] 
     * have the same content.
     */
    @Override 
    public boolean equals(Object o)
    {
    	StateComparator sc = new StateComparator();
    	return sc.compare(this, (State)o) == 0;
    }
        
    
    /**
     * Evaluate the cost of this state as the sum of the number of moves from the initial state and 
     * the estimated number of moves to the goal state using the heuristic stored in the instance 
     * variable heu. 
     * 
     * If heu == TileMismatch, add up numMoves and the return values from computeNumMismatchedTiles().
     * If heu == MahattanDist, add up numMoves and the return values of computeMahattanDistance(). 
     * If heu == DoubleMoveHeuristic, add up numMoves and the return value of computeNumSingleDoubleMoves(). 
     * 
     * @return estimated number of moves from the initial state to the goal state via this state.
     * @throws IllegalArgumentException if heuristic is none of TileMismatch, MahattanDist, DoubleMoveHeuristic. 
     */
    public int cost() throws IllegalArgumentException
    {
        switch(heu){
            // f = g + h or cost = numMoves + heuristic value
            case TileMismatch:
                return numMoves + computeNumMismatchedTiles();
            case ManhattanDist:
                return numMoves + computeManhattanDistance();
            case DoubleMoveHeuristic:
                return numMoves + computeNumSingleDoubleMoves();
            default:
                throw new IllegalArgumentException("Heuristic not recognized");
        }
    }

    
    /**
     * Compare two states by the cost. Let c1 and c2 be the costs of this state and the argument state s.
     * 
     * @return -1 if c1 < c2 
     *          0 if c1 = c2 
     *          1 if c1 > c2 
     *          
     * Call the method cost(). This comparison will be used in maintaining the OPEN list by the A* algorithm.
     */
    @Override
    public int compareTo(State s)
    {
        int c1 = cost();
        int c2 = s.cost();
        return Integer.compare(c1, c2);
    }
    

    /**
     * Return the value of the private variable numMismatchedTiles if it is non-negative, and compute its 
     * value otherwise. 
     * 
     * @return the number of mismatched tiles between this state and the goal state. 
     */
	private int computeNumMismatchedTiles()
	{
		if(numMismatchedTiles == -1){ // Need to compute its value
			numMismatchedTiles = 0;
			int[][] goal = {
		        {1, 2, 3},
		        {8, 0, 4},
		        {7, 6, 5}
		    };
			for(int i = 0; i < 3; i++) { // Compare each board square with the goal state
	    		for(int j = 0; j < 3; j++) {
	    			int val = goal[i][j];
	    			if(val != 0 && val != board[i][j]) numMismatchedTiles++; // 0 Tile doesn't count as mismatched
	    		}
	    	}
		}
		return numMismatchedTiles;
	}

	
	/**
	 * Return the value of the private variable ManhattanDistance if it is non-negative, and compute its value 
	 * otherwise.
	 * 
	 * @return the Manhattan distance between this state and the goal state. 
	 */
	private int computeManhattanDistance()
	{
		if(ManhattanDistance == -1){ // Need to compute its value
			ManhattanDistance = 0;
	        int[][] goalPos = { // coordinates of each value in goal state
               {1, 1}, // {x, y}, position of 0
               {0, 0}, // position of 1...
               {0, 1},
               {0, 2},
               {1, 2},
               {2, 2},
               {2, 1},
               {2, 0},
               {1, 0}
           };
            for(int i = 0; i < 3; i++) {
                for(int j = 0; j < 3; j++) {
                    int square = board[i][j]; // the value at the current square
                    if(square != 0) { // empty tile doesn't count towards the missplaced
                        ManhattanDistance += Math.abs(i - goalPos[square][0]) + Math.abs(j - goalPos[square][1]);
                    }
                }
            }
		}
		return ManhattanDistance;
	}
	
	
	/**
	 * Return the value of the private variable numSingleDoubleMoves if it is non-negative, and compute its value 
	 * otherwise. 
     * 
     * A double move counts as one move. For example, if a tile is two moves away from its goal position,
     * it can be moved there in one double move, so it contributes 1 to numSingleDoubleMoves. If a tile is
     * three moves away from its goal position, it can be moved there in one double move and one single move,
     * so it contributes 2 to numSingleDoubleMoves.
	 * 
	 * @return the value of the private variable numSingleDoubleMoves that bounds from below the number of moves, 
	 *         single or double, which will take this state to the goal state.
	 */
	private int computeNumSingleDoubleMoves()
	{
		if(numSingleDoubleMoves == -1){
            numSingleDoubleMoves = 0;
            int[][] goalPos = { // coordinates of each value in goal state
                {1, 1}, // {x, y}, position of 0
                {0, 0}, // position of 1...
                {0, 1},
                {0, 2},
                {1, 2},
                {2, 2},
                {2, 1},
                {2, 0},
                {1, 0}
            };
            int numSingleMoves = 0;
            for(int i = 0; i < 3; i++) {
                for(int j = 0; j < 3; j++) {
                    int square = board[i][j]; // the value at the current square
                    if(square != 0) { // empty tile doesn't count towards the missplaced
                        int dist = Math.abs(i - goalPos[square][0]) + Math.abs(j - goalPos[square][1]);
                        numSingleMoves += dist; // Count manhattan distance or single moves for each square to get to goal
                    }
                }
            }
            // Divide by 2 since double moves change two tiles, essentially two single moves combined
            // We can round up since if you are left with one single move, you still have to make a full move
            numSingleDoubleMoves = (numSingleMoves + 1) / 2;
        }
        return numSingleDoubleMoves;
	}
}
